---
title: "[Docker] 도커로 컨테이너 다루기"
categories:
    - study
tags:
    - kubernetes
    - k8s
    - docker

toc: true
toc_sticky: true
toc_label: Table of contents

last_modified_at: 2021-11-11
---

## 4.2 도커로 컨테이너 다루기

### 4.2.1 컨테이너 이미지 알아보기

#### 이미지 검색하고 내려받기
- 이미지는 레지스트리라고 하는 저장소에 모여 있다.
- 레지스트리는 도커 허브처럼 공개된 유명 레지스트리일 수도 있고, 내부에 구축한 레지스트리일 수도 있다.
- 이미지는 레지스트리 웹 사이트에서 직접 검색해도 되고, 명령 창에서 쿠버네티스 마스터 노드에 접속해 검색할 수도 있다.

```sh
# 이미지 검색 Ex) docker search [검색어]
docker search nginx
```
```sh
# 이미지 내려받기 Ex) docker pull [NAME]
docker pull nginx
```

#### 이미지 태그
- `태그`는 이름이 동일한 이미지에 추가하는 식별자이다.
- 이미지를 내려받거나 이미지를 기반으로 컨테이너를 구동할 때 `태그`를 명시하지 않으면 기본 적으로 `latest` 태그를 사용한다. 
- 최신 버전은 `latest`, 안정화 버전은 `stable`

```sh
# 최신 버전
docker pull nginx:latest 또는 docker pull nginx
# 안정화 버전
docker pull nginx:stable
```

#### 이미지의 레이어 구조
- 컨테이너 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 Zip 같은 압축 파일과 비슷하다.
- 압축 파일은 파일의 개수에 따라 전체 용량이 증가하지만 이미지는 같은 내용일 경우 여러 이미지에 `동일한 레이어를 공유`하므로 전체 용량이 감소한다.

```sh
# 내려받은 이미지 조회 Ex) docker images [NAME]
docker images nginx
```
```sh
# stable 이미지 생성 과정에 대한 자세한 이력을 볼 수 있다.
# 또한 latest 버전과 stable 버전에서 서로 레이어를 공유하고 있음을 확인할 수 있다.
docker history nginx:stable
docker history nginx:latest
```

### 4.2.2 컨테이너 실행하기
```sh
# 새로운 컨테이너를 실행
docker run -d --restart always nginx
```

옵션에 따라 달라지는 컨테이너 시작 방법
{: .notice--info}

|값|컨테이너 비정상 종료 시|도커 서비스 시작 시|
|:---:|:---:|:---:|
|no (기본값)|컨테이너를 재시작하지 않음|컨테이너를 시작하지 않음|
|on-failure|컨테이너를 재시작함|컨테이너를 시작함|
|always|컨테이너를 재시작함|컨테이너를 시작함|
|unless-stopped|컨테이너를 재시작함|사용자가 직접 정하지 않은 컨테이너만 시작함|

```sh
# 생성한 컨테이너 상태를 확인
docker ps
```

- CONTAINER ID
  - 컨테이너를 식별하기 위한 고유 ID

- IMAGE
  - 컨테이너를 만드는 데 사용한 이미지

- COMMAND
  - 컨테이너가 생성될 때 내부에서 작동할 프로그램을 실행하는 명령어

- CREATED
  - 컨테이너가 생성 된 시각

- STATUS
  - 컨테이너가 작동을 시작한 시각 (CREATED와 달리 컨테이너를 재시작할 경우 초기화)

- PORTS
  - 컨테이너가 사용하는 포트와 프로토콜

- NAMES
  - 컨테이너 이름을 표시 (docker run 시에 --name 옵션으로 직접 지정 가능)

```sh
# docker ps 시 -f 옵션으로 필터링 할 수 있다. (문자열 포함)
# ex) docker ps -f id=[CONTAINER ID]
docker ps -f id=ef
```

자주 사용하는 필터링 키
{: .notice--info}

- id
  - 컨테이너 아이디

- name
  - 컨테이너 이름

- label
  - 컨테이너 레이블

- exited
  - 컨테이너가 종료됬을 때 반환하는 숫자 코드

- status
  - 컨테이너의 작동 상태

- ancestor
  - 컨테이너가 사용하는 이미지

컨테이너는 `변경 불가능한 인프라`를 지향한다.  
따라서 초기에 인프라를 구성하면 임의로 디렉터리 연결이나 포트 노출 같은 설정을 변경할 수 없다.  
번거롭더라도 컨테이너 설정의 변경이 필요하고자 한다면 새로운 컨테이너를 생성해야 한다.  
이러한 특성 덕분에 컨테이너로 배포된 인프라는 배포된 상태를 유지한다는 장점이 있다.

```sh
# 컨테이너 외부에서 접속할 수 있도록 포트포워딩을 해준다.
docker run -d -p 8080:80 --name nginx-exposed --restart always nginx
```

```sh
# 지정한 name 을 필터링 하여 컨테이너가 작동하는지 확인
docker ps -f name=nginx-exposed
```

- 컨테이너가 정상적으로 동작한다면 외부에서 8080으로 접근 시 해당 컨테이너의 80포트 서비스로 접근할 수 있다.


### 4.2.3 컨테이너 내부 파일 변경하기
- 도커는 컨테이너 내부에서 컨테이너 외부의 파일을 사용할 수 있는 방법을 크게 4가지 제공 한다.

- docker cp
  - 호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사
  - 컨테이너에 임시로 필요한 파일이 있는 경우 또는 컨테이너에 저장돼 있는 설정 및 로그를 추출해 확인하는 목적으로 사용

- Dockerfile ADD
  - 이미지는 Dockerfile을 기반으로 만들어지는데, Dockerfile에 ADD 라는 구문으로 이미지를 빌드할 떄 지정한 파일이 이미지 내부로 복사 된다.
  - 사용자가 원하는 파일을 선택해 사용할 수 없다는 단점이 있다.

- 바인드 마운트
  - 호스트 파일의 시스템과 컨테이너 내부를 연결해 양쪽에 동시에 반영 된다.
  - 컨테이너가 바뀌어도 없어지면 안 되는 자료는 이 방법으로 보존할 수 있다.

- 볼륨
  - 바인드 마운트와 비슷하지만, 도커가 관리하는 볼륨을 컨테이너와 연결한다는 점에서 다르다.
  - 도커가 관리하는 볼륨 공간을 NS와 같은 공유 디렉터리에 생성 한다면 다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용할 수 있다.

- 보통 서비스를 하면서 파일을 보존해야 되기 때문에 바인드 마운트 또는 볼륨이 효과적인 방법이다.

|구분|docker cp|Dockerfile ADD|바인드 마운트|볼륨|
|:---:|:---:|:---:|:---:|:---:|
|컨테이너 적용|구동 중 복사|이미지 생성 시 복사|구동 시 디렉터리 연결|구동 시 도커의 볼륨 연결|
|파일 보관 위치|컨테이너 내부|컨테이너 내부|호스트(디렉터리)|호스트(도커 볼륨)
|주 활용 용도|임시 파일|컨테이너 생성 시 필요한 파일|보존이 필요한 파일|보존이 필요한 파일|
|관리 편의성|좋지 못함|좋음|좋음|매우 좋음|
|파일 보존성|좋지 못함|좋음|매우 좋음|매우 좋음|

### 4.2.4 사용하지 않는 컨테이너 정리하기
- `docker stop` 명령어로 사용하지 않는 컨테이너를 정지할 수 있다.
```sh
# 컨테이너를 생성하는 데 사용한 이미지를 기준으로 필터링하여 컨테이너 상태 확인
docker ps -f ancestor=nginx
```
```sh
# -q 옵션으로 컨테이너 ID만 출력 하도록하여 인자에 담아 일괄 정지 처리
docker stop $(docker ps -q -f ancestor=nginx)
```

- 컨테이너를 정지를 하였고, 컨테이너를 다시 구동하고 싶다면 `docker start <컨테이너 ID>` 를 실행 한다.

- 컨테이너를 삭제 하기 위해서는 `docker rm` 명령어를 사용 한다.
```sh
# -q 옵션으로 컨테이너 ID만 출력 하도록하여 인자에 담아 일괄 삭제 처리
# -a 옵션의 경우 정지 된 컨테이너 상태까지 모두 보여준다.
docker rm $(docker ps -aq -f ancestor=nginx)
```

- 컨테이너를 모두 삭제 하였지만, 내려받은 이미지는 아직 남아 있어 공간을 차지 한다. 따라서 사용하지 않는 이미지라면 이미지도 삭제 처리.
```sh
docker rmi $(docker images -q nginx)
```